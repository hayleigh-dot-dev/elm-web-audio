{"version":3,"sources":["virtual-audio.js","main.js"],"names":["defer","f","setTimeout","AudioContext","window","webkitAudioContext","VirtualAudioGraph","context","opts","$context","$nodes","vPrev","autostart","resume","flatten","graph","nodes","depth","forEach","node","i","type","key","connections","base","length","oldNodes","newNodes","Object","patches","created","updated","removed","newNode","oldNode","push","data","connection","split","j","Math","max","properties","oldProp","newProp","label","value","oldConnection","newConnection","values","vGraph","vCurr","prepare","diff","patch","_destroyNode","_removeProperty","_disconnect","_createNode","_setProperty","_connect","suspend","$node","createAnalyser","createBufferSource","destination","createBiquadFilter","createChannelMerger","createChannelSplitter","createConstantSource","createConvolver","maxDelayTime","find","createDelay","createDynamicsCompressor","createGain","feedforward","feedback","createIIRFilter","mediaElement","createMediaElementSource","document","querySelector","createMediaStreamDestination","createOscillator","createPanner","createStereoPanner","createWaveShaper","console","warn","prop","start","stop","disconnect","linearRampToValueAtTime","currentTime","method","target","time","default","a","b","param","connect","audio","addEventListener","state","App","Elm","Main","init","ports","updateAudio","subscribe","update"],"mappings":"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","file":"main.86e4e755.js","sourceRoot":"../example","sourcesContent":["const defer = f => setTimeout(f, 0)\nconst AudioContext = window.AudioContext || window.webkitAudioContext\n\nexport default class VirtualAudioGraph {\n  // Static Methods ============================================================\n  //\n  static prepare (graph = []) {\n    // The first step in preparing the graph is to key each virtual node.\n    // This is how we perform a diff between graphs and calculate what has\n    // changed each update.\n    const key = (graph, base = '') => {\n      graph.forEach((node, i) => {\n        // RefNodes always have a key, and they also\n        // cannot have connections or properties\n        // so we can just return early and move on.\n        if (node.type === 'RefNode') return\n        // Assign the node a key if it didn't already have one.\n        // This is how we track changes to the graph in a slightly\n        // more organised way\n        if (!node.key) node.key = `${base}_${i}`\n\n        // Recursively assign keys to this nodes connections.\n        if (node.connections && node.connections.length > 0) {\n          key(node.connections, node.key)\n        }\n      })\n\n      return graph\n    }\n\n    // It is often most natural to represent the audio graph as a list\n    // of trees, using RefNodes to \"jump\" between chains of node\n    // connections. This isns't the easiest data structure to deal with\n    // however, so the next step in preparation is the flatten the graph\n    // into a single array.\n    const flatten = (graph, nodes = {}, depth = 0) => {\n      graph.forEach((node, i) => {\n        // Don't push RefNodes to the flat graph.\n        if (node.type !== 'RefNode') nodes[node.key] = node\n        if (node.connections) flatten(node.connections, nodes, depth + 1)\n        // If we're deeper than the root of the graph, replace\n        // this node with a reference to itself by key.\n        if (depth > 0) graph[i] = { type: 'RefNode', key: node.key }\n      })\n\n      return nodes\n    }\n\n    return flatten(key(graph))\n  }\n\n  //\n  static diff (oldNodes, newNodes) {\n    const patches = { created: [], updated: [], removed: [] }\n\n    for (const newNode of Object.values(newNodes)) {\n      const oldNode = oldNodes[newNode.key]\n\n      // A node with newNode.key does not exist in the old graph, so this must\n      // mean we've created a brand new node.\n      if (!oldNode) {\n        patches.created.push({ type: 'node', key: newNode.key, data: newNode })\n\n        newNode.connections.forEach(connection => {\n          patches.created.push({ type: 'connection', key: newNode.key, data: connection.key.split('.') })\n        })\n\n      // A node with the same key exists in both graphs, but the type has changed\n      // (eg osc -> gain) so we need to recreate the node.\n      } else if (oldNode.type !== newNode.type) {\n        patches.updated.push({ type: 'node', key: newNode.key, data: newNode })\n\n        newNode.connections.forEach(connection => {\n          patches.created.push({ type: 'connection', key: newNode.key, data: connection.key.split('.') })\n        })\n\n      // A node with the same key exists in both graphs and the node hasn't\n      // fundamentally changed, so now we check whether properties or connections\n      // have changed.\n      } else {\n        // Checking properties...\n        for (let j = 0; j < Math.max(oldNode.properties.length, newNode.properties.length); j++) {\n          const oldProp = oldNode.properties[j]\n          const newProp = newNode.properties[j]\n\n          //\n          if (!oldProp) {\n            patches.created.push({ type: 'property', key: oldNode.key, data: newProp })\n          } else if (!newProp) {\n            patches.removed.push({ type: 'property', key: oldNode.key, data: oldProp })\n          } else if (oldProp.label !== newProp.label) {\n            patches.removed.push({ type: 'property', key: oldNode.key, data: oldProp })\n            patches.created.push({ type: 'property', key: oldNode.key, data: newProp })\n          } else if (oldProp.value !== newProp.value) {\n            patches.updated.push({ type: 'property', key: oldNode.key, data: newProp })\n          }\n        }\n\n        // Checking connections...\n        for (let j = 0; j < Math.max(oldNode.connections.length, newNode.connections.length); j++) {\n          const oldConnection = oldNode.connections[j]\n          const newConnection = newNode.connections[j]\n\n          //\n          if (!oldConnection) {\n            patches.created.push({ type: 'connection', key: oldNode.key, data: newConnection.key.split('.') })\n          } else if (!newConnection) {\n            patches.removed.push({ type: 'connection', key: oldNode.key, data: oldConnection.key.split('.') })\n          } else if (oldConnection.key !== newConnection.key) {\n            patches.removed.push({ type: 'connection', key: oldNode.key, data: oldConnection.key.split('.') })\n            patches.created.push({ type: 'connection', key: oldNode.key, data: newConnection.key.split('.') })\n          }\n        }\n      }\n\n      delete oldNodes[newNode.key]\n    }\n\n    for (const oldNode of Object.values(oldNodes)) {\n      patches.removed.push({ type: 'node', key: oldNode.key, data: oldNode })\n    }\n\n    return patches\n  }\n\n  // Constructor ===============================================================\n  //\n  constructor (context = new AudioContext(), opts = {}) {\n    // Borrowing a convetion from virtual dom libraries, the $ sign //is used to\n    // indicate \"real\" Web Audio bits, and the v- prefix is used to indicate\n    // virtual elements.\n\n    // $context is a reference to the `AudioContext` either passed in or created\n    // on construction.\n    this.$context = context\n    // A reference to the real graph of audio nodes\n    this.$nodes = {}\n    // We keep track of the prebious graph so we can perform a diff and work out\n    // what has changed between updates.\n    this.vPrev = {}\n\n    // In most modern browsers an Audio Context starts in a suspended state and\n    // requires some user interaction before it can be resumed. Still, we can\n    // attempt to resume the context ourselves in the developer passes in the\n    // `autostart` option.\n    if (opts.autostart) this.resume()\n  }\n\n  // Public Methods ============================================================\n  //\n  update (vGraph = []) {\n    // The accompanying library of virtual node functions\n    // encourages a nested tree-like approach to describing\n    // audio graphs. This isn't the easiest structure to deal\n    // with, however, so a preparation step serves to wrestle\n    // the graph into a more suitable shape.\n    const vCurr = VirtualAudioGraph.prepare(vGraph)\n\n    // A diff tracks everything that has been removed, created,\n    // and updated between updates. We perform this step so we\n    // only touch the audio nodes that need to be changed in some\n    // way.\n    const diff = VirtualAudioGraph.diff(this.vPrev, vCurr)\n\n    // Remove nodes and properties from the graph.\n    diff.removed.forEach(patch => {\n      switch (patch.type) {\n        case 'node':\n          this._destroyNode(patch.key)\n          break\n        case 'property':\n          this._removeProperty(patch.key, patch.data)\n          break\n        case 'connection':\n          this._disconnect(patch.key, patch.data)\n          break\n      }\n    })\n\n    // Create new nodes and add new properties to\n    // the graph.\n    diff.created.forEach(patch => {\n      switch (patch.type) {\n        case 'node':\n          this._createNode(patch.key, patch.data)\n          break\n        case 'property':\n          this._setProperty(patch.key, patch.data)\n          break\n        case 'connection':\n          defer(() => this._connect(patch.key, patch.data))\n          break\n      }\n    })\n\n    // Update existing nodes and properties in the\n    // graph.\n    diff.updated.forEach(patch => {\n      switch (patch.type) {\n        case 'node':\n          this._destroyNode(patch.key)\n          this._createNode(patch.key, patch.data)\n          break\n        case 'property':\n          this._setProperty(patch.key, patch.data)\n          break\n        case 'connection':\n          // Connections can't be updated\n          break\n      }\n    })\n\n    // Store the current graph for next time.\n    this.vPrev = vCurr\n  }\n\n  // A thin wrapper of the `AudioContext.suspend()` method. This\n  // bassically exists so developers don't have to reach in and\n  // touch the \"real\" audio context directly.\n  suspend () {\n    this.$context.suspend()\n  }\n\n  // A thin wrapper of the `AudioContext.resume()` method. This\n  // bassically exists so developers don't have to reach in and\n  // touch the \"real\" audio context directly.\n  resume () {\n    this.$context.resume()\n  }\n\n  // Private Methods ===========================================================\n  //\n  _createNode (key, { type, properties }) {\n    let $node = null\n\n    //\n    switch (type) {\n      case 'AnalyserNode':\n        $node = this.$context.createAnalyser()\n        break\n      case 'AudioBufferSourceNode':\n        $node = this.$context.createBufferSource()\n        break\n      case 'AudioDestinationNode':\n        $node = this.$context.destination\n        break\n      case 'BiquadFilterNode':\n        $node = this.$context.createBiquadFilter()\n        break\n      case 'ChannelMergerNode':\n        $node = this.$context.createChannelMerger()\n        break\n      case 'ChannelSplitterNode':\n        $node = this.$context.createChannelSplitter()\n        break\n      case 'ConstantSourceNode':\n        $node = this.$context.createConstantSource()\n        break\n      case 'ConvolverNode':\n        $node = this.$context.createConvolver()\n        break\n      case 'DelayNode':\n        const maxDelayTime = properties.find(({ label }) => label === 'maxDelayTime')\n        $node = this.$context.createDelay((maxDelayTime && maxDelayTime.value) || 1)\n        break\n      case 'DynamicsCompressorNode':\n        $node = this.$context.createDynamicsCompressor()\n        break\n      case 'GainNode':\n        $node = this.$context.createGain()\n        break\n      case 'IIRFilterNode':\n        const feedforward = properties.find(({ label }) => label === 'feedforward')\n        const feedback = properties.find(({ label }) => label === 'feedback')\n        $node = this.$context.createIIRFilter(\n          (feedforward && feedforward.value) || [0],\n          (feedback && feedback.value) || [1]\n        )\n        break\n      case 'MediaElementAudioSourceNode':\n        const mediaElement = properties.find(({ label }) => label === 'mediaElement')\n        $node = this.$context.createMediaElementSource(\n          document.querySelector(mediaElement.value)\n        )\n        break\n      case 'MediaStreamAudioDestinationNode':\n        $node = this.$context.createMediaStreamDestination()\n        break\n        // TODO: How should I handle creating / grabbing the media stream?\n        // case 'MediaStreamAudioSourceNode':\n        //   $node = this.$context.createMediaStreamSource(\n\n        //   )\n        //   break\n      case 'OscillatorNode':\n        $node = this.$context.createOscillator()\n        break\n      case 'PannerNode':\n        $node = this.$context.createPanner()\n        break\n      case 'StereoPannerNode':\n        $node = this.$context.createStereoPanner()\n        break\n      case 'WaveShaperNode':\n        $node = this.$context.createWaveShaper()\n        break\n      //\n      default:\n        console.warn(`Invalide node type of: ${type}. Defaulting to GainNode to avoid crashing the AudioContext.`)\n        $node = this.$context.createGain()\n    }\n\n    this.$nodes[key] = $node\n\n    //\n    properties.forEach(prop => this._setProperty(key, prop))\n\n    // Certain nodes like oscillators must be started before they will produce\n    // noise. We make the assumption that these nodes should always start\n    // immediately after they have been created, so if a `start` method exists we\n    // call it.\n    if ($node.start) $node.start()\n  }\n\n  //\n  _destroyNode (key) {\n    const $node = this.$nodes[key]\n\n    // Certain nodes like oscillators can be stopped. It probably doesn't make\n    // much of a difference calling this method, but we do just in case!\n    if ($node.stop) $node.stop()\n\n    // Calling disconnect with no arguments will disconnect this node from\n    // everything.\n    $node.disconnect()\n\n    // Finally remove the node from the graph and let the GC do its job.\n    delete this.$nodes[key]\n  }\n\n  //\n  _setProperty (key, { type, label, value }) {\n    const $node = this.$nodes[key]\n\n    switch (type) {\n      case 'NodeProperty':\n        $node[label] = value\n        break\n      case 'AudioParam':\n        $node[label].linearRampToValueAtTime(value, this.$context.currentTime + 0.01)\n        break\n      case 'ScheduledAudioParam':\n        $node[label][value.method](value.target, value.time)\n        break\n    }\n  }\n\n  //\n  _removeProperty (key, { type, label, value }) {\n    const $node = this.$nodes[key]\n\n    switch (type) {\n      case 'NodeProperty':\n        break\n      case 'AudioParam':\n        $node[label].value = $node[label].default\n        break\n      case 'ScheduledAudioParam':\n        // TODO: work out how to cancel scheduled updates\n        break\n    }\n  }\n\n  //\n  _connect (a, [b, param = null]) {\n    if (b) this.$nodes[a].connect(param ? this.$nodes[b][param] : this.$nodes[b])\n  }\n\n  //\n  _disconnect (a, [b, param = null]) {\n    if (b) this.$nodes[a].disconnect(param ? this.$nodes[b][param] : this.$nodes[b])\n  }\n}\n","/* global AudioContext */\nimport { Elm } from './Main.elm'\nimport VirtualAudioGraph from './virtual-audio'\n\nconst context = new AudioContext()\nconst audio = new VirtualAudioGraph(context)\n\n// Chrome autplay policy demans some user interaction\n// takes place before the AudioContext can be resumed.\nwindow.addEventListener('click', () => {\n  if (context.state === 'suspended') context.resume()\n})\n\nconst App = Elm.Main.init({\n  node: document.querySelector('#app')\n})\n\nApp.ports.updateAudio.subscribe(graph => {\n  audio.update(graph)\n})\n"]}